name: Migrate Releases

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  migrate:
    runs-on: ubuntu-latest
    timeout-minutes: 360

    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          clean: true

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyGithub requests

      - name: Migrate latest release from LIMEs to PrtivateLIMEs
        env:
          MIGRATE_TOKEN: ${{ secrets.MIGRATE_TOKEN }}
          OLD_OWNER: areteruhiro
          OLD_REPO: PrtivateLIMEs
          NEW_OWNER: areteruhiro
          NEW_REPO: LIMEs
        run: |
          if [ -z "$MIGRATE_TOKEN" ]; then
            echo "ERROR: MIGRATE_TOKEN is empty" >&2
            exit 1
          fi

          python << 'EOF'
          import os, requests, tempfile, sys
          from github import Github
          from github.GithubException import UnknownObjectException

          token = os.environ['MIGRATE_TOKEN']
          src = Github(token).get_repo(f"{os.environ['OLD_OWNER']}/{os.environ['OLD_REPO']}")
          dst = Github(token).get_repo(f"{os.environ['NEW_OWNER']}/{os.environ['NEW_REPO']}")

          releases = list(src.get_releases())
          if not releases:
              print("No releases found in source repository.")
              sys.exit(0)

          rel = releases[0]  # 最新リリース
          tag = rel.tag_name or ""
          print(f"Source release tag: '{tag}'")
          print("Source release assets (names):")
          for a in rel.get_assets():
              print("  -", a.name)

          try:
              dst.get_release(tag)
              print(f"→ Skipping existing release: {tag}")
              sys.exit(0)
          except UnknownObjectException:
              pass

          print(f"→ Migrating latest release: {tag}")
          new_rel = dst.create_git_release(
              tag=tag,
              name=rel.title or tag,
              message=rel.body or "",
              draft=rel.draft,
              prerelease=rel.prerelease
          )

          session = requests.Session()
          session.headers.update({
              'Authorization': f'token {token}',
              'Accept': 'application/octet-stream',
              'User-Agent': 'github-release-migration-script'
          })

          uploaded_any = False

          # Build target filename and ensure it contains the required prefix
          if tag.startswith('v'):
              target_filename = f"PrtivateLIMEs-{tag}.apk"
          else:
              target_filename = f"PrtivateLIMEs-v{tag}.apk"

          print(f"Computed target upload filename: '{target_filename}'")

          # Guard: require the filename to include the exact substring
          if "PrtivateLIMEs-" not in target_filename:
              print(f"ERROR: target filename '{target_filename}' does not include 'PrtivateLIMEs-' as required. Aborting.", file=sys.stderr)
              # Do not proceed with upload if name doesn't match requirement
              sys.exit(1)

          for asset in rel.get_assets():
              # Only consider .apk assets
              if not asset.name.lower().endswith('.apk'):
                  print(f"   • skipping non-apk asset: {asset.name}")
                  continue

              print(f"   • asset found: {asset.name} -> will be uploaded as: {target_filename}")

              asset_url = f"https://api.github.com/repos/{os.environ['OLD_OWNER']}/{os.environ['OLD_REPO']}/releases/assets/{asset.id}"
              tmp_path = None
              try:
                  # stream the download to avoid loading entire file into memory
                  with session.get(asset_url, stream=True, allow_redirects=True) as r:
                      print(f"     Download HTTP status: {r.status_code}")
                      if r.status_code != 200:
                          print(f"⚠️ Failed to download asset {asset.name}, status code: {r.status_code}")
                          print(f"Response text (truncated): {r.text[:400]}")
                          continue
                      with tempfile.NamedTemporaryFile(delete=False, suffix=os.path.splitext(asset.name)[1]) as tmp:
                          for chunk in r.iter_content(chunk_size=8192):
                              if chunk:
                                  tmp.write(chunk)
                          tmp_path = tmp.name

                  # Upload with the normalized filename
                  print(f"     Uploading as {target_filename} ...")
                  new_rel.upload_asset(
                      path=tmp_path,
                      name=target_filename,
                      label=target_filename
                  )
                  uploaded_any = True
              except Exception as e:
                  print(f"⚠️ Error handling asset {asset.name}: {e}")
              finally:
                  # cleanup temp file
                  try:
                      if tmp_path and os.path.exists(tmp_path):
                          os.remove(tmp_path)
                  except Exception:
                      pass

              # After uploading the first APK, stop — requirement was to upload the apk file only
              if uploaded_any:
                  print("→ Uploaded first APK and stopping further uploads (per config).")
                  break

          if not uploaded_any:
              print("⚠️ No APK assets were found to upload. Nothing was uploaded.")
              # List the assets again for investigation
              print("Assets present on source release (detailed):")
              for a in rel.get_assets():
                  print(f"  - name: {a.name}, size: {a.size}, id: {a.id}")
              # Exit with non-zero so the workflow shows failure and you can inspect logs
              sys.exit(1)
          else:
              print("✅ Migration complete")
          EOF
